<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jaxes的博客</title>
  
  <subtitle>一个游戏开发者的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-08T15:29:25.748Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jaxes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity3D学习笔记之UGUI：Canvas</title>
    <link href="http://yoursite.com/2018/11/27/Unity3D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BUGUI%EF%BC%9ACanvas/"/>
    <id>http://yoursite.com/2018/11/27/Unity3D学习笔记之UGUI：Canvas/</id>
    <published>2018-11-27T09:35:30.000Z</published>
    <updated>2018-12-08T15:29:25.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Canvas组件："><a href="#Canvas组件：" class="headerlink" title="Canvas组件："></a>Canvas组件：</h2><ol><li>Rander Mode（渲染模式）：</li></ol><hr><p>   <img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板1.png" alt=""></p><ol><li><p>（默认）Screen Space - Overlay（屏幕空间叠加模式）：自动填充场景，使Canvas自动适应Game窗口的大小，并且在此模式下Rect Transform组件不可编辑，其中的所有值将由Canvas自动设置</p><ol><li><p>Pixel Perfect：开启时，UI元素将在渲染时调整到最近的像素，使外观更加锐利</p></li><li><p>Sort Order：表示该Canvas渲染的顺序，数字越大越迟进渲染管线，位置处于越上层</p></li><li><p>Target Display：表示渲染到的目标显示窗</p><hr><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板2.png" alt=""></p><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/演示1.png" alt=""></p><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/演示2.png" alt=""></p></li></ol></li><li><p>Screen Space - Camera（屏幕空间相机模式）：和1类似，但是Canvas是直接填充到相机的截锥体中，并且可以设置独立的相机，允许UI元素有深度感</p><ol><li><p>Pixel Perfect：同上</p></li><li><p>Render Camera：渲染此Canvas的相机</p></li><li><p>Plane Distance：Canvas离相机的距离</p></li><li><p>Sorting Layer：渲染顺序层级</p></li><li><p>Order in Layer：在当前渲染顺序层级的子渲染顺序</p><hr><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板3.png" alt=""></p></li></ol><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/演示3.png" alt=""></p></li><li><p>World Space（世界空间模式）：此模式下的UI元素可以是场景中的静态元素或者是可移动元素，并且Rect Transform组件允许设置，不再随屏幕的变化而变化</p><ol><li>Event Camera：检测点击UI等事件的相机</li><li>Sorting Layer：同上</li><li>Order in Layer：同上</li></ol></li></ol><h2 id="Canvas-Scaler组件："><a href="#Canvas-Scaler组件：" class="headerlink" title="Canvas Scaler组件："></a>Canvas Scaler组件：</h2><ol><li><p>UI Scale Mode（缩放模式）：</p><hr><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板4.png" alt=""></p><ol><li><p>Constant Pixel Size：固定像素尺寸，无论分辨率是多少，占用的像素都是一样的</p><ol><li>Scale Factor：缩放比例，默认为1</li></ol><hr><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板5.png" alt=""></p></li><li><p>Scale With Screen Size：根据屏幕大小进行缩放</p><ol><li>Reference Resolution：开发时设置的分辨率，所有的缩放基于这个分辨率</li><li>Screen Match Mode：屏幕适配模式<ol><li>Match Width Or Height（默认）：匹配宽度或高度<ol><li>Match：宽度和高度的缩放权重，横屏游戏用Height匹配，竖屏游戏用Width匹配</li></ol></li><li>Expend：如果屏幕实际大小大于参考标准时，选用此模式，它会适当放大Canvas</li><li>Shrink：如果屏幕实际大小小于参考标准时，选用此模式，它会适当缩小Canvas</li></ol></li></ol><hr><p><img src="/2018/11/27/Unity3D学习笔记之UGUI：Canvas/面板6.png" alt=""></p></li><li><p>Constant Physical Size：物理大小不变模式</p><ol><li>Physical Unit：物理单位<ol><li>Centimeters（厘米）：0.01米</li><li>Millimeters（毫米）：0.1厘米</li><li>Inches（英寸）：英制单位</li><li>Points（积分）：1/72英寸</li><li>Picas（派卡）：1/6英寸</li></ol></li><li>Fallback Screen DPI：屏幕DPI</li><li>Default Sprite DPI：默认精灵DPI</li></ol></li></ol></li><li><p>Reference Pixels Per Unit（参考像素每单位）：每个单位的参考像素，和1x1x1的Cube来比较，棱长1表示一个单位，一个单位由n个像素组成，n即为此项的值，默认为100</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Canvas组件：&quot;&gt;&lt;a href=&quot;#Canvas组件：&quot; class=&quot;headerlink&quot; title=&quot;Canvas组件：&quot;&gt;&lt;/a&gt;Canvas组件：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Rander Mode（渲染模式）：&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
      <category term="游戏开发" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D学习笔记之碰撞器和触发器</title>
    <link href="http://yoursite.com/2018/11/21/Unity3D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://yoursite.com/2018/11/21/Unity3D学习笔记之碰撞器和触发器/</id>
    <published>2018-11-21T14:15:22.000Z</published>
    <updated>2018-11-21T14:16:31.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="碰撞器种类："><a href="#碰撞器种类：" class="headerlink" title="碰撞器种类："></a>碰撞器种类：</h2><ol><li>Box Collider（盒碰撞器）——立方体</li><li>Sphere Collider（球碰撞器）——球体</li><li>Capsule Collider（胶囊碰撞器）——胶囊体</li><li>Mesh Collider（网格碰撞器）——从物体的网格创建一个碰撞器，不能与其他网格碰撞器相碰撞</li><li>Wheel Collider（轮碰撞器）——特殊的碰撞器，用于创建车或其他的交通工具的车轮</li></ol><h2 id="碰撞器属性："><a href="#碰撞器属性：" class="headerlink" title="碰撞器属性："></a>碰撞器属性：</h2><ol><li>Material：材质</li><li>Is Trigger：开启触发器</li><li>Radius：半径</li><li>Center：中心</li><li>Size：碰撞器的大小</li><li>Convex（网格碰撞器特有）：如激活，该网格碰撞器将会和其他网格碰撞器碰撞，突起的网格碰撞器限制在255个三角形面内。</li></ol><h2 id="碰撞器类型："><a href="#碰撞器类型：" class="headerlink" title="碰撞器类型："></a>碰撞器类型：</h2><ol><li>Static Collider（静态碰撞器）：只有碰撞器，没有刚体。基本保持静止或者轻微的移动，一般应用于环境模型，和刚体碰撞时不会移动</li><li>Rigidbody Collider（刚体碰撞器）：同时附加了刚体和碰撞器。移动完全受脚本和物理引擎的影响。</li><li>Kinematic Rigidbody Collider（运动学刚体碰撞器）：同时附加刚体和碰撞器，并且激活刚体组件的IsKinematic。移动必须通过修改其Transform组件，不受力的影响。能影响其他的刚体，和其他碰撞器碰撞时不会受影响，但是会触发碰撞函数。</li><li>Character Controllers（角色控制器）：允许高速运动时立刻转身，可以执行碰撞检测保证角色可以沿墙滑动或者上下台阶。受重力影响，不受碰撞产生的力影响，可以由代码施加的力推动。不具有物理特性。如果想让角色控制器推开其他刚体或者对象，可以在对象附加的脚本中添加OnControllerColliderHit()函数，使得碰撞生效。</li></ol><h2 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a>触发器：</h2><p>在碰撞器的属性面版上勾选上IsTrigger便成为了触发器</p><p>两者区别：碰撞器根据物理引擎引发碰撞，产生碰撞的效果；触发器被物理引擎所忽略，没有碰撞效果</p><h2 id="碰撞信息检测函数："><a href="#碰撞信息检测函数：" class="headerlink" title="碰撞信息检测函数："></a>碰撞信息检测函数：</h2><ol><li>OnCollisionEnter(Collision collision)当开始产生碰撞时调用此函数</li><li>OnCollisionExit(Collision collision)当结束碰撞时调用此函数</li><li>OnCollisionStay(Collision collision)当持续接触时调用此函数</li></ol><h2 id="触发信息检测函数："><a href="#触发信息检测函数：" class="headerlink" title="触发信息检测函数："></a>触发信息检测函数：</h2><p>基本和碰撞信息检测函数类似</p><ol><li>OnTriggerEnter(Collision collision)</li><li>OnTriggerExit(Collision collision)</li><li>OnTriggerStay(Collision collision)</li></ol><h2 id="碰撞信息和触发信息："><a href="#碰撞信息和触发信息：" class="headerlink" title="碰撞信息和触发信息："></a>碰撞信息和触发信息：</h2><p>​                                <strong>碰撞后有碰撞检测并有碰撞信息发出</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Static Collider 静态碰撞器</th><th style="text-align:center">Rigidbody Collider 刚体碰撞器</th><th style="text-align:center">Kinematic  Rigidbody Collider 运动学刚体碰撞器</th><th style="text-align:center">Static  Trigger Collider 静态触发碰撞器</th><th style="text-align:center">Rigidbody  Trigger Collider 刚体触发碰撞器</th><th style="text-align:center">Kinematic Rigidbody  Trigger Collider 运动学刚体触发碰撞器</th></tr></thead><tbody><tr><td style="text-align:center">Static Collider 静态碰撞器</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Rigidbody Collider 刚体碰撞器</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Kinematic Rigidbody Collider  运动学刚体碰撞器</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Static Trigger Collider 静态触发碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Rigidbody Trigger Collider 刚体触发碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>​                                        <strong>碰撞后有触发信息</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Static Collider 静态碰撞器</th><th style="text-align:center">Rigidbody Collider 刚体碰撞器</th><th style="text-align:center">Kinematic  Rigidbody Collider 运动学刚体碰撞器</th><th style="text-align:center">Static  Trigger Collider 静态触发碰撞器</th><th style="text-align:center">Rigidbody  Trigger Collider 刚体触发碰撞器</th><th style="text-align:center">Kinematic Rigidbody  Trigger Collider 运动学刚体触发碰撞器</th></tr></thead><tbody><tr><td style="text-align:center">Static Collider 静态碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Rigidbody Collider 刚体碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Kinematic Rigidbody Collider 运动学刚体碰撞器</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Static Trigger Collider 静态触发碰撞器</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Rigidbody Trigger Collider 刚体触发碰撞器</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;碰撞器种类：&quot;&gt;&lt;a href=&quot;#碰撞器种类：&quot; class=&quot;headerlink&quot; title=&quot;碰撞器种类：&quot;&gt;&lt;/a&gt;碰撞器种类：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Box Collider（盒碰撞器）——立方体&lt;/li&gt;
&lt;li&gt;Sphere Collider
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
      <category term="游戏开发" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D学习笔记之Rigidbody(刚体组件)</title>
    <link href="http://yoursite.com/2018/10/28/Unity3D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRigidbody-%E5%88%9A%E4%BD%93%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/28/Unity3D学习笔记之Rigidbody-刚体组件/</id>
    <published>2018-10-28T06:38:54.000Z</published>
    <updated>2018-10-28T07:01:04.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rigidbody面板各属性："><a href="#Rigidbody面板各属性：" class="headerlink" title="Rigidbody面板各属性："></a>Rigidbody面板各属性：</h2><ol><li><p>Mass（质量）：单位kg</p></li><li><p>Drag（阻力）</p></li><li><p>Angular Drag（角阻力）</p></li><li><p>Use Gravity（开启重力）</p></li><li><p>Is Kinematic（开启动力学模式）：开启之后将不在受物理引擎的影响而只能通过Transform属性来操作，这个选项适用于模拟平台的移动或带有铰链关节连接刚体的动画。</p></li><li><p>Interpolate（插值）：</p><p>​    None：没有插值。</p><p>​    Interpolate：内插值，基于前一帧的Transform来平滑的此次的Transform。</p><p>​    Extrapolate：外插值，基于后一帧的Transform来平滑的此次的Transform。</p></li><li><p>Collision Detection（碰撞检测模式）：</p><p>​    Discrete：默认选项，检测场景中其他所有碰撞体进行碰撞检测。</p><p>​    Continuous：连续碰撞检测。此模式适用于那些需要与采用了连续动态碰撞检测的对象相碰撞的对象。</p><p>​    Continuous Dynamic：连续动态检测模式。</p></li><li><p>Constraints（束缚）：</p><p>Freeze Position（位置冻结）</p><p>Freeze Rotation（角度冻结）</p></li></ol><h2 id="脚本中控制刚体的常用方法："><a href="#脚本中控制刚体的常用方法：" class="headerlink" title="脚本中控制刚体的常用方法："></a>脚本中控制刚体的常用方法：</h2><ol><li>AddForce：添加一个力到刚体，使刚体开始移动</li><li>AddForceAtPosition：施加在某一个点上的力，这将可能在物体上施加扭矩力</li><li>Addtorque：为刚体增加一个扭矩</li><li>IsSleeping：判断刚体是否被休眠</li><li>MovePosition：移动刚体到某个位置</li><li>MoveRotation：使刚体旋转到某个位置</li><li>Sleep：使刚体至少休眠一帧</li><li>WakeUp：使刚体终止休眠</li><li>GetPointVelocity：获取刚体的绝对速度</li><li>GetRelativePointVelocity：获取刚体相对于某点的速度</li><li>ResetInertiaTensor：重置惯性张量和旋转</li></ol><h2 id="刚体物理学知识补充："><a href="#刚体物理学知识补充：" class="headerlink" title="刚体物理学知识补充："></a>刚体物理学知识补充：</h2><ol><li><p>刚体：指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。</p></li><li><p>惯性张量：描述刚体绕点旋转的惯性大小</p></li><li><p>转动惯量：描述刚体绕轴旋转的惯性大小</p></li><li><p>惯性张量与转动惯量的关系：</p><p>对于三维空间中任意一参考点 K与以此参考点为原点的直角坐标系的惯性张量<strong>I</strong>可以表示为下面的3X3的矩阵</p><p><img src="/2018/10/28/Unity3D学习笔记之Rigidbody-刚体组件/matrix.jpg" alt=""></p><p>这里，矩阵的对角元素 Ixx、Iyy、Izz分别为对于 x-轴、y-轴、z-轴的转动惯量</p></li></ol><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol><li>操作一个物体可以操作其刚体或者Transform属性，两者选其一即可；</li><li>使用物理系统时可以通过在游戏对象的刚体上添加AddForce()或者AddTorque()函数达到通过脚本来添加作用力或扭矩力，来对刚体进行控制；</li><li>使用刚体组件也要同时使用碰撞器组件；</li><li>父子对象不应该同时具有刚体；</li><li>不应该缩放刚体的父级。</li><li>运动学刚体不受力、碰撞或关节控制，完全由动画或代码（控制Transform属性）驱动，但运动学刚体可以通过碰撞或关节影响其他刚体的运动。非运动学刚体则受力、碰撞或关节控制。</li></ol><h2 id="详细API请参考："><a href="#详细API请参考：" class="headerlink" title="详细API请参考："></a>详细API请参考：</h2><p><a href="https://docs.unity3d.com/ScriptReference/Rigidbody.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Rigidbody.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Rigidbody面板各属性：&quot;&gt;&lt;a href=&quot;#Rigidbody面板各属性：&quot; class=&quot;headerlink&quot; title=&quot;Rigidbody面板各属性：&quot;&gt;&lt;/a&gt;Rigidbody面板各属性：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Mass（质量）：
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
      <category term="游戏开发" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！</title>
    <link href="http://yoursite.com/2018/10/25/C++%E7%9A%84ifstream%E4%B8%AD%E4%BD%BF%E7%94%A8eof%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E4%B8%A4%E6%AC%A1%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%8D%E6%98%AFeof%E7%9A%84%E9%94%85%EF%BC%81/"/>
    <id>http://yoursite.com/2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/</id>
    <published>2018-10-24T17:09:44.000Z</published>
    <updated>2018-11-21T14:27:13.952Z</updated>
    
    <content type="html"><![CDATA[<p>写C++文件输入输出流时遇到的小问题</p><p>当我执行以下代码时，最后的值会打印两次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">2</span>,d = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="function">ofstream <span class="title">FileOpen</span><span class="params">(<span class="string">"Test.txt"</span>)</span></span>;</span><br><span class="line">        FileOpen&lt;&lt;<span class="string">"HelloWorld!\n"</span>;</span><br><span class="line">        FileOpen&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d;</span><br><span class="line">        FileOpen.close();</span><br><span class="line">        <span class="function">ifstream <span class="title">Filein</span><span class="params">(<span class="string">"Test.txt"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!Filein.eof())</span><br><span class="line">        &#123;</span><br><span class="line">                Filein.get(ch);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;ch;</span><br><span class="line">        &#125;</span><br><span class="line">        Filein.close();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/error.png" alt=""></p><p>问题在于get()方法：<strong>get()方法返回当前文件“内置指针”指向的下一个字符，然后再将“内置指针”向后移动。</strong></p><p>也就是说“内置指针”是在执行完get()后才指向下一个字符。</p><h3 id="下面来分析一下波："><a href="#下面来分析一下波：" class="headerlink" title="下面来分析一下波："></a>下面来分析一下波：</h3><p>当“内置指针”指向c时，get()返回d的值给ch，然后“内置指针”向后移动指向d，打印d的值，此时eof()返回false，而循环继续进行;</p><p>再次get()，当前“内置指针”指向d，返回的是d后面的值，然而d后面是EOF，读取失败，无法赋值给ch，ch依然为d的值，再次打印了一次d的值，get()完后，“内置指针”指向了EOF，eof()返回true，则退出而循环。</p><p>结束。</p><h3 id="原理已经懂了，进行以下的改造即可输出正确："><a href="#原理已经懂了，进行以下的改造即可输出正确：" class="headerlink" title="原理已经懂了，进行以下的改造即可输出正确："></a>原理已经懂了，进行以下的改造即可输出正确：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">2</span>,d = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="function">ofstream <span class="title">FileOpen</span><span class="params">(“Test.txt”)</span></span>;</span><br><span class="line">        FileOpen &lt;&lt; <span class="string">"Helloworld!\n"</span>;</span><br><span class="line">        FileOpen &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d;</span><br><span class="line">        FileOpen.close();</span><br><span class="line">        <span class="function">ifstream <span class="title">Filein</span><span class="params">(<span class="string">"Test.txt"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(Filein.get(ch),!Filein.eof())</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/result.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写C++文件输入输出流时遇到的小问题&lt;/p&gt;
&lt;p&gt;当我执行以下代码时，最后的值会打印两次：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="文件输入输出流" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Unity终止协程的问题</title>
    <link href="http://yoursite.com/2018/10/23/Unity%E7%BB%88%E6%AD%A2%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/23/Unity终止协程的问题/</id>
    <published>2018-10-23T15:17:30.000Z</published>
    <updated>2018-10-23T15:36:11.258Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做项目的时候发现，调用<code>StopCoroutine()</code>来终止一个正在运行的协程的时候，无法终止协程。然后通过查资料发现了一下两种办法：</p><h3 id="利用字符串来启动和终止协程："><a href="#利用字符串来启动和终止协程：" class="headerlink" title="利用字符串来启动和终止协程："></a>利用字符串来启动和终止协程：</h3><p>比如，我有一个协程<code>IEnumerator MoveAnimation()</code>，启动时要用<code>StartCoroutine(&quot;MoveAnimation&quot;)</code>，终止的时候用<code>StopCoroutine(&quot;MoveAnimation&quot;)</code>，才能正确终止协程。</p><p>要想传参，可以使用 <code>StartCoroutine(&quot;MoveAnimation&quot;, object)</code>来传参。</p><h3 id="不用字符串来启动和终止协程的方法："><a href="#不用字符串来启动和终止协程的方法：" class="headerlink" title="不用字符串来启动和终止协程的方法："></a>不用字符串来启动和终止协程的方法：</h3><p>定义一个<code>Coroutine</code>类型的变量<code>coroutine</code>，在<code>StartCoroutine(MoveAnimation())</code>后接收返回的值：</p><p><code>coroutine=StartCoroutine(&quot;MoveAnimation&quot;);</code></p><p>然后终止协程的时候利用<code>StopCoroutine(coroutine)</code>来终止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做项目的时候发现，调用&lt;code&gt;StopCoroutine()&lt;/code&gt;来终止一个正在运行的协程的时候，无法终止协程。然后通过查资料发现了一下两种办法：&lt;/p&gt;
&lt;h3 id=&quot;利用字符串来启动和终止协程：&quot;&gt;&lt;a href=&quot;#利用字符串来启动和终止协程：&quot; 
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
      <category term="游戏开发" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Unity界面UGUI遮挡的问题</title>
    <link href="http://yoursite.com/2018/10/22/Unity%E7%95%8C%E9%9D%A2UGUI%E9%81%AE%E6%8C%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/22/Unity界面UGUI遮挡的问题/</id>
    <published>2018-10-22T12:22:45.000Z</published>
    <updated>2018-11-04T14:53:17.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>在使用Unity的UGUI时候，重叠的UI控件可能会导致某一个控件点击失败，如下图：</p><p><img src="/2018/10/22/Unity界面UGUI遮挡的问题/pause.png" alt=""></p><p>在前面的图片挡住了后面的Button，导致后面的Button无法触发点击事件，此时只要把图片的Image组件的<code>Raycast Target</code>的勾选取消即可解决遮挡的问题：</p><p><img src="/2018/10/22/Unity界面UGUI遮挡的问题/image.png" alt=""></p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>鼠标点击屏幕实际上是以点击的点为原点，发射一条垂直屏幕向里的射线，然后通过射线与第一个物体的相交来判断是否点击到该物体。取消了<code>Raycast Target</code>选项表明不作为射线相交的对象，则不会挡住后面的Button</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h3&gt;&lt;p&gt;在使用Unity的UGUI时候，重叠的UI控件可能会导致某一个控件点击失败，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
      <category term="游戏开发" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>steam商店页面的探索队列无法打开</title>
    <link href="http://yoursite.com/2018/10/21/steam%E5%95%86%E5%BA%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%8E%A2%E7%B4%A2%E9%98%9F%E5%88%97%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2018/10/21/steam商店页面的探索队列无法打开/</id>
    <published>2018-10-21T15:43:04.000Z</published>
    <updated>2018-10-21T16:04:55.042Z</updated>
    
    <content type="html"><![CDATA[<p>steam的探索队列可能会显示“你所在的地区不提供此物品”，此时如何解决呢？</p><h3 id="用浏览器打开steam商店页面："><a href="#用浏览器打开steam商店页面：" class="headerlink" title="用浏览器打开steam商店页面："></a>用浏览器打开steam商店页面：</h3><p><img src="/2018/10/21/steam商店页面的探索队列无法打开/home.png" alt="steam商店页面"></p><h3 id="然后按F12打开浏览器控制台（Console）："><a href="#然后按F12打开浏览器控制台（Console）：" class="headerlink" title="然后按F12打开浏览器控制台（Console）："></a>然后按F12打开浏览器控制台（Console）：</h3><p><img src="/2018/10/21/steam商店页面的探索队列无法打开/console.png" alt="控制台页面"></p><h3 id="然后在右边输入以下代码："><a href="#然后在右边输入以下代码：" class="headerlink" title="然后在右边输入以下代码："></a>然后在右边输入以下代码：</h3><p><code>$J.post(&quot;/app/7&quot;, { sessionid: g_sessionID, appid_to_clear_from_queue: APPID });</code></p><p>注意：其中的<code>APPID</code>由你当前队列的网址的以下数字串决定，把你对应的数字串替换上面代码的<code>APPID</code>即可</p><p><img src="/2018/10/21/steam商店页面的探索队列无法打开/appid.png" alt="网址中的APPID"></p>]]></content>
    
    <summary type="html">
    
      steam的探索队列可能会显示“你所在的地区不提供此物品”，此时如何解决呢？
    
    </summary>
    
      <category term="杂项" scheme="http://yoursite.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="steam" scheme="http://yoursite.com/tags/steam/"/>
    
      <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
