{"meta":{"title":"Jaxes的博客","subtitle":"一个游戏开发者的小站","description":"技术博客","author":"Jaxes","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-10-21T14:43:14.000Z","updated":"2018-10-24T18:25:48.614Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-10-21T14:41:43.000Z","updated":"2018-10-24T18:25:37.677Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-10-21T14:13:54.000Z","updated":"2018-10-24T17:52:23.696Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一个游戏开发爱好者的小站，欢迎你的到来。本博客主要用于分享游戏开发方面的一些技术，同时还会分享一些游戏有关的东西，欢迎游戏开发同好以及游戏爱好者的到来。 邮箱：jaxeszhang@qq.comGithub：https://github.com/Jaxes"}],"posts":[{"title":"Unity3D学习笔记之Rigidbody(刚体组件)","slug":"Unity3D学习笔记之Rigidbody(刚体组件)","date":"2018-10-28T06:38:54.000Z","updated":"2018-10-28T06:47:45.626Z","comments":true,"path":"2018/10/28/Unity3D学习笔记之Rigidbody(刚体组件)/","link":"","permalink":"http://yoursite.com/2018/10/28/Unity3D学习笔记之Rigidbody(刚体组件)/","excerpt":"","text":"Rigidbody面板各属性： Mass（质量）：单位kg Drag（阻力） Angular Drag（角阻力） Use Gravity（开启重力） Is Kinematic（开启动力学模式）：开启之后将不在受物理引擎的影响而只能通过Transform属性来操作，这个选项适用于模拟平台的移动或带有铰链关节连接刚体的动画。 Interpolate（插值）： ​ None：没有插值。 ​ Interpolate：内插值，基于前一帧的Transform来平滑的此次的Transform。 ​ Extrapolate：外插值，基于后一帧的Transform来平滑的此次的Transform。 Collision Detection（碰撞检测模式）： ​ Discrete：默认选项，检测场景中其他所有碰撞体进行碰撞检测。 ​ Continuous：连续碰撞检测。此模式适用于那些需要与采用了连续动态碰撞检测的对象相碰撞的对象。 ​ Continuous Dynamic：连续动态检测模式。 Constraints（束缚）： Freeze Position（位置冻结） Freeze Rotation（角度冻结） 脚本中控制刚体的常用方法： AddForce：添加一个力到刚体，使刚体开始移动 AddForceAtPosition：施加在某一个点上的力，这将可能在物体上施加扭矩力 Addtorque：为刚体增加一个扭矩 IsSleeping：判断刚体是否被休眠 MovePosition：移动刚体到某个位置 MoveRotation：使刚体旋转到某个位置 Sleep：使刚体至少休眠一帧 WakeUp：使刚体终止休眠 GetPointVelocity：获取刚体的绝对速度 GetRelativePointVelocity：获取刚体相对于某点的速度 ResetInertiaTensor：重置惯性张量和旋转 刚体物理学知识补充： 刚体：指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 惯性张量：描述刚体绕点旋转的惯性大小 转动惯量：描述刚体绕轴旋转的惯性大小 惯性张量与转动惯量的关系： 对于三维空间中任意一参考点 K与以此参考点为原点的直角坐标系的惯性张量I可以表示为下面的3X3的矩阵 \\matrix.jpg) 这里，矩阵的对角元素 Ixx、Iyy、Izz分别为对于 x-轴、y-轴、z-轴的转动惯量 注意事项： 操作一个物体可以操作其刚体或者Transform属性，两者选其一即可； 使用物理系统时可以通过在游戏对象的刚体上添加AddForce()或者AddTorque()函数达到通过脚本来添加作用力或扭矩力，来对刚体进行控制； 使用刚体组件也要同时使用碰撞器组件； 父子对象不应该同时具有刚体； 不应该缩放刚体的父级。 运动学刚体不受力、碰撞或关节控制，完全由动画或代码（控制Transform属性）驱动，但运动学刚体可以通过碰撞或关节影响其他刚体的运动。非运动学刚体则受力、碰撞或关节控制。 详细API请参考：https://docs.unity3d.com/ScriptReference/Rigidbody.html","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！","slug":"C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！","date":"2018-10-24T17:09:44.000Z","updated":"2018-10-24T17:17:50.336Z","comments":true,"path":"2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/","link":"","permalink":"http://yoursite.com/2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/","excerpt":"","text":"写C++文件输入输出流时遇到的小问题 当我执行以下代码时，最后的值会打印两次： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;fstream&gt;using namespace std;int main(void)&#123; int a = 0,b = 1,c = 2,d = 3; char ch; ofstream FileOpen(\"Test.txt\"); FileOpen&lt;&lt;\"HelloWorld!\\n\"; FileOpen&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d; FileOpen.close(); ifstream Filein(\"Test.txt\"); if(！Filein.eof()) &#123; Filein.get（ch）; cout&lt;&lt;ch; &#125; Filein.close(); cout&lt;&lt;endl; system(\"pause\"); return 0;&#125; 问题在于get()方法：get()方法返回当前文件“内置指针”指向的下一个字符，然后再将“内置指针”向后移动。 也就是说“内置指针”是在执行完get()后才指向下一个字符。 下面来分析一下波：当“内置指针”指向c时，get()返回d的值给ch，然后“内置指针”向后移动指向d，打印d的值，此时eof()返回false，而循环继续进行; 再次get()，当前“内置指针”指向d，返回的是d后面的值，然而d后面是EOF，读取失败，无法赋值给ch，ch依然为d的值，再次打印了一次d的值，get()完后，“内置指针”指向了EOF，eof()返回true，则退出而循环。 结束。 原理已经懂了，进行以下的改造即可输出正确：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;fstream&gt;using namespace std;int main(void)&#123; int a = 0,b = 1,c = 2,d = 3; char ch; ofstream FileOpen(“Test.txt”); FileOpen &lt;&lt; \"Helloworld!\\n\"; FileOpen &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d; FileOpen.close(); ifstream Filein(\"Test.txt\"); if(Filein.get(ch),!Filein.eof()) &#123; cout &lt;&lt; ch; &#125; cout &lt;&lt; endl; system(\"pause\"); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"文件输入输出流","slug":"文件输入输出流","permalink":"http://yoursite.com/tags/文件输入输出流/"}]},{"title":"Unity终止协程的问题","slug":"Unity终止协程的问题","date":"2018-10-23T15:17:30.000Z","updated":"2018-10-23T15:36:11.258Z","comments":true,"path":"2018/10/23/Unity终止协程的问题/","link":"","permalink":"http://yoursite.com/2018/10/23/Unity终止协程的问题/","excerpt":"","text":"最近在做项目的时候发现，调用StopCoroutine()来终止一个正在运行的协程的时候，无法终止协程。然后通过查资料发现了一下两种办法： 利用字符串来启动和终止协程：比如，我有一个协程IEnumerator MoveAnimation()，启动时要用StartCoroutine(&quot;MoveAnimation&quot;)，终止的时候用StopCoroutine(&quot;MoveAnimation&quot;)，才能正确终止协程。 要想传参，可以使用 StartCoroutine(&quot;MoveAnimation&quot;, object)来传参。 不用字符串来启动和终止协程的方法：定义一个Coroutine类型的变量coroutine，在StartCoroutine(MoveAnimation())后接收返回的值： coroutine=StartCoroutine(&quot;MoveAnimation&quot;); 然后终止协程的时候利用StopCoroutine(coroutine)来终止。","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"Unity界面UGUI遮挡的问题","slug":"Unity界面UGUI遮挡的问题","date":"2018-10-22T12:22:45.000Z","updated":"2018-10-22T13:39:42.152Z","comments":true,"path":"2018/10/22/Unity界面UGUI遮挡的问题/","link":"","permalink":"http://yoursite.com/2018/10/22/Unity界面UGUI遮挡的问题/","excerpt":"","text":"解决方法：在使用Unity的UGUI时候，重叠的UI控件可能会导致某一个控件点击失败，如下图： 在前面的图片挡住了后面的Button，导致后面的Button无法触发点击事件，此时只要把图片的Image组件的Raycast Target的勾选取消即可解决遮挡的问题： 原理：鼠标点击屏幕实际上是以点击的点为原点，发射一条垂直屏幕向里的射线，然后通过射线与第一个物体的相交来判断是否点击到该物体。取消了Raycast Target选项表明不作为射线相交的对象，则不会挡住后面的Button","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"steam商店页面的探索队列无法打开","slug":"steam商店页面的探索队列无法打开","date":"2018-10-21T15:43:04.000Z","updated":"2018-10-21T16:04:55.042Z","comments":true,"path":"2018/10/21/steam商店页面的探索队列无法打开/","link":"","permalink":"http://yoursite.com/2018/10/21/steam商店页面的探索队列无法打开/","excerpt":"","text":"steam的探索队列可能会显示“你所在的地区不提供此物品”，此时如何解决呢？ 用浏览器打开steam商店页面： 然后按F12打开浏览器控制台（Console）： 然后在右边输入以下代码：$J.post(&quot;/app/7&quot;, { sessionid: g_sessionID, appid_to_clear_from_queue: APPID }); 注意：其中的APPID由你当前队列的网址的以下数字串决定，把你对应的数字串替换上面代码的APPID即可","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"steam","slug":"steam","permalink":"http://yoursite.com/tags/steam/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]}]}