{"meta":{"title":"Jaxes的博客","subtitle":"一个游戏开发者的小站","description":"技术博客","author":"Jaxes","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-10-21T14:13:54.000Z","updated":"2018-11-04T15:19:15.771Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一个游戏开发爱好者的小站，欢迎你的到来。本博客主要用于分享游戏开发方面的一些技术，同时还会分享一些游戏有关的东西，欢迎游戏开发同好以及游戏爱好者的到来。 邮箱：jaxeszhang@qq.comGithub：https://github.com/Jaxescnblog：https://www.cnblogs.com/JaxesZ/"},{"title":"分类","date":"2018-10-21T14:41:43.000Z","updated":"2018-10-24T18:25:37.677Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-21T14:43:14.000Z","updated":"2018-10-24T18:25:48.614Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Lua学习笔记（六）","slug":"Lua学习笔记（六）","date":"2019-07-19T09:58:00.000Z","updated":"2019-07-20T03:31:48.399Z","comments":true,"path":"2019/07/19/Lua学习笔记（六）/","link":"","permalink":"http://yoursite.com/2019/07/19/Lua学习笔记（六）/","excerpt":"","text":"Lua面向对象封装123456789101112131415161718192021222324252627282930-- 元类People=&#123;isHumen=true&#125; -- 此处定义的元素都是相当于C++的静态成员变量-- 基类方法newfunction People:new(o,n,a) o=o or &#123;&#125; setmetatable(o,self) -- self相当于C++的this指针，但是这里指代的是元类People而不是对象o self.__index=self o.name=n -- 用self代替o相当于C++中给静态成员变量赋值 o.age=a return oend-- 基类元方法__tostringfunction People:__tostring() local sum=\"名字为：\"..self.name..\"\\n年龄为：\"..self.age -- 此处self指代的是实际调用时的对象 return sumend-- 基类方法walkfunction People:walk() print(\"我正在走！\")end-- 创建对象me=People:new(nil,\"Jaxes\",21)-- 调用对象中的函数print(me) -- 等价于print(tostring(me))me:walk() -- 等价于me.walk(me) 继承123456789101112131415161718192021-- 类Worker派生自People类Worker=People:new()-- 派生类function Worker:new(o,n,a,id) o=o or People:new(o,n,a) setmetatable(o,self) self.__index=self o.id=id return oendfunction Worker:__tostring() local sum=People.__tostring(self) sum=sum..\"\\nID为：\"..self.id return sumendworker=Worker:new(nil,\"kaka\",55,01)print(worker)worker:walk() -- 继承自父类函数walk 多态这个部分暂时还不清楚怎么搞，暂时做为后续储备内容","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Lua学习笔记（五）","slug":"Lua学习笔记（五）","date":"2019-07-18T15:12:00.000Z","updated":"2019-07-20T03:31:34.252Z","comments":true,"path":"2019/07/18/Lua学习笔记（五）/","link":"","permalink":"http://yoursite.com/2019/07/18/Lua学习笔记（五）/","excerpt":"","text":"Lua模块与包模块类似于一个封装库 创建方法： 创建一个table 把需要导出的常量、函数放入其中 返回该table 123456789101112131415161718192021-- 文件名为mymodule.lua-- 定义一个名为mymodule的模块mymodule=&#123;&#125;-- 定义一个常量mymodule.constant=\"这是一个常量\"-- 定义一个函数function mymodule.func1() io.write(\"这是一个公有函数！\\n\")endlocal function func2() print(\"这是一个私有函数！\")endfunction module.func3() func2()endreturn mymodule require函数12345678910111213-- require函数用于加载模块，使用方法：require(\"mymodule\")require \"mymodule\"-- 执行require后返回由模块常量或函数组成的table，并且还会定义一个包含该table的全局变量require(\"mymodule\")print(module.constant)mymodule.func3()-- 也可以创建别名local m=require(\"mymodule\")print(m.constant)m.func3() 加载机制： https://www.runoob.com/lua/lua-modules-packages.html Metatable（元表）元表允许改变table的行为，每个行为关联了对应的元方法 12345678910111213141516--[[作用：对指定的table设置metatable参数列表： table：操作对象 metatable：元表返回值：绑定好对象的table]]setmetatable(table,metatable)--[[作用：返回对象的元表参数列表： table：操作对象返回值：元表]]getmetatable(table) __index元方法123456789101112131415161718192021-- 当使用table中的某个键key时，会查找table中的该键key，如果没有这个键key则会寻找该table的metatable中的_index键，如果__index包含一个table，Lua会在表格中查找键值为key的元素other=&#123;foo=3&#125;t=setmetatable(&#123;&#125;,&#123;_index=other&#125;) -- t中没有foo键，调用foo是在metatable中查找__index对应的table，再在该table上查找foo键t.foo -- 输出：3-- __index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。如果__index包含一个函数，Lua就会调用该函数，table和键作为参数传递给函数。mytable=setmetatable(&#123;key1=\"value1\"&#125;,&#123; __index=function(mytable,key) if key == \"key2\" then return \"metatablevalue\" else return nil end end &#125;)print(mytable.key1,mytable.key2)--[[输出结果：value1 metatablevalue]] Lua查找table元素规则： 在表中查找，如果找到，返回该元素，找不到则继续 判断该表是否有元表，如果没有元表，返回 nil，有元表则继续 判断元表有没有__index方法，如果__index方法为nil，返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值 __newindex元方法1234567891011121314151617181920212223242526272829-- __newindex方法用于对表更新，__index则用来对表访问-- 给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作mymetatable=&#123;&#125;mytable=setmetatable(&#123;key1=\"value1\"&#125;,&#123;__newindex=mymetatable&#125;)print(mytable.key1)mytable.newkey=\"新值2\"print(mytable.newkey,mymetatable.newkey)mytable.key1 = \"新值1\"print(mytable.key1,mymetatable.key1)--[[输出结果：value1nil 新值2新值1 nil]]-- 如果__newindex元方法是一个函数，则会把该table，该key，该value作为参数传进函数mytable = setmetatable(&#123;key1 = \"value1\"&#125;, &#123; __newindex = function(mytable, key, value) rawset(mytable, key, \"\\\"\"..value..\"\\\"\") end&#125;)mytable.key1 = \"new value\"mytable.key2 = 4print(mytable.key1,mytable.key2)--[[输出结果：new value \"4\"]] 为表添加操作符（类似于运算符重载） 元方法 对应运算符 __add + __sub -（减号） __mul * __div / __mod % _unm -（负号） __concat .. __eq == __lt &lt; __le &lt;= __call元方法123456789101112131415-- __call元方法在该表被当成函数来调用时会调用mytable=setmetatable(&#123;10&#125;,&#123; __call=function(mytable,newtable) local sum=0 for i=1,#mytable do sum=sum+mytable[i] end for i=1,#newtable do sum=sum+newtable[i] end return sum end &#125;)newtable=&#123;10,20,30&#125;print(mytable(newtable)) -- 输出结果：70 __tostring元方法1234567891011-- __tostring 元方法用于修改表的输出行为mytable = setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring = function(mytable) local sum = 0 for k, v in pairs(mytable) do sum = sum + v end return \"表所有元素的和为 \" .. sum end&#125;)print(mytable) -- 输出结果：表所有元素的和为 60","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Lua学习笔记（四）","slug":"Lua学习笔记（四）","date":"2019-07-17T14:07:00.000Z","updated":"2019-07-20T03:31:30.196Z","comments":true,"path":"2019/07/17/Lua学习笔记（四）/","link":"","permalink":"http://yoursite.com/2019/07/17/Lua学习笔记（四）/","excerpt":"","text":"Lua数组一维数组123456789101112131415161718192021array=&#123;\"Lua\",\"Java\",\"C++\"&#125;for i=0,2 do print(array[i])end--[[输出结果：nilLuaJava结果分析：Lua索引值以1为起始，也可以指定0开始]]-- 以负数为数组索引值array=&#123;&#125;for i=-2,2 do array[i]=i*2endfor i=-2,2 do print(array[i])end 多维数组123456789101112131415-- 初始化数组array=&#123;&#125;for i=1,3 do array[i]=&#123;&#125; for j=1,3 do array[i][j]=i*j endend-- 访问数组for i=1,3 do for j=1,3 do print(array[i][j]) endend Lua迭代器一种对象，能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。 在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素 泛型for迭代器泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量 泛型for的执行过程https://www.runoob.com/lua/lua-iterators.html Lua迭代器类型 无状态的迭代器 多状态的迭代器 无状态的迭代器不保留任何状态的迭代器，每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。如：ipairs函数 多状态的迭代器迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，方法： 使用闭包（类似于lambda表达式，该表达式能包含函数本身以及外部引用变量，外部引用变量类似于lambda表达式中[]内捕获的外部变量） 将所有状态信息封装到table内 12345678910111213141516171819202122array=&#123;\"Google\",\"Apple\"&#125;function elementIterator(collection) local index=0 local count=#collection -- 闭包函数 return function() index=index+1 if index&lt;=count then return collection[index] end endendfor element in elementIterator(array) do print(element)end--[[输出结果：GoogleApple]] Lua table（表）table是一种数据结构，可以用于创建不同的数据类型：数组、字典等 table的特点： 使用关联型数组，可以用任意非nil的类型作为数组的索引 大小不固定，可以根据需要扩容 可以用于解决模块（module）、包（package）和对象（Object） table的构造1234567891011-- 初始化表mytable=&#123;&#125; -- 最简单的构造函数-- 指定值mytable[1]=\"Lua\"-- 移除引用mytable=nil-- Lua垃圾回收会释放内存-- 注意：table间的赋值是传引用，两者指向同一个内存，只有当没有任何变量指向该内存（即所有table变量都指向了nil），Lua的垃圾回收机制才会清理相对应的内存 table操作1234567891011121314151617181920212223242526272829303132333435363738--[[作用：列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开参数列表： table：操作对象 sep：分隔符 start：起始索引 end：末尾索引返回值：连接后的字符串]]table.concat(table[,sep[,start[,end]]])--[[作用：在table的数组部分指定位置(pos)插入值为value的一个元素参数列表： table：操作对象 pos：插入位置，默认为数组部分的末尾 value：插入的值返回值：]]table.insert(table,[pos,]value)--[[作用：删除table数组部分位于pos位置的元素，其后的元素会被前移参数列表： table：操作对象 pos：删除的元素位置，默认为最后一个元素的位置返回值：删除的元素的值]]table.remove(table[,pos])--[[作用：对给定的table进行升序排序，数值按照数值大小，字符串按照首字母ASCCI码排序参数列表： table：操作对象 comp：比较方法，接收两个参数，返回一个布尔值，为true不交换，为false交换返回值：nil]]table.sort(table[,comp])","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Lua学习笔记（三）","slug":"Lua学习笔记（三）","date":"2019-07-16T13:57:00.000Z","updated":"2019-07-20T03:31:25.778Z","comments":true,"path":"2019/07/16/Lua学习笔记（三）/","link":"","permalink":"http://yoursite.com/2019/07/16/Lua学习笔记（三）/","excerpt":"","text":"Lua函数函数定义123456-- []为可选部分[local] function function_name(argument1,argument2) -- do something [return result] -- 可以返回多个值，每个值以逗号隔开end-- 函数名表示该函数的引用，与C/C++的函数指针类似 可变参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 与C语言类似，在函数参数列表中使用三点...表示函数有可变的参数function add(...) local s=0 for i,v in ipairs&#123;...&#125; do -- 注意这里是&#123;&#125;，&#123;...&#125;表示一个由所有变长参数构成的table（这里实质是一个数组） s=s+v end return sendprint(add(3,4,5,6,7)) -- 输出：25-- 可变参数也可以赋值给一个变量function average(...) result=0 local arg=&#123;...&#125; -- arg为一个table，局部变量 for i,v in ipairs(arg) do result=result+v end print(\"总共传入 \" .. #arg .. \" 个数\") -- #也可以用于计算table中的元素个数 return result/#argendprint(\"平均值为\",average(10,5,3,4,5,6))-- 也可以通过select(\"#\",...)来获取可变参数的数量function average(...) result = 0 local arg=&#123;...&#125; for i,v in ipairs(arg) do result = result + v end print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\") -- 等价于#arg return result/select(\"#\",...)endprint(\"平均值为\",average(10,5,3,4,5,6))-- 也可能同时需要固定参数和可变参数function fwrite(fmt,...) return io.write(string.format(fmt,...))endfwrite(\"rua\\n\") -- fmt=\"rua\"，没有可变参数fwrite(\"%d%d\\n\",1,2) -- fmt=\"%d%d\"，可变参数为1和2-- select函数do function foo(...) for i = 1, select('#', ...) do -- 获取参数总数 local arg = select(i, ...); -- 读取第i个可变实参 print(\"arg\", arg); end end foo(1, 2, 3, 4); end Lua运算符Lua运算符类型 算术运算符 关系运算符 逻辑运算符 其他运算符 算术运算符除了^用于计算幂，其他加、减、乘、除、取余、取反等都与C/C++相同 关系运算符除了不等于号~=，其他等于、大于、小于、大于等于、小于等于等都与C/C++相同 逻辑运算符1234-- 只有当值为nil或false才是假，其他都为真（0也为真）and -- 类似于C/C++的&amp;&amp;，当为假时返回从左到右表达式第一个为假的值（nil或false），否则返回后者or -- 类似于C/C++的||，当为真时返回从左到右表达式第一个为真的值（非nil和非false），否则返回后者not -- 类似于C/C++的！ 其他运算符12.. -- 用于连接两个字符串或非字符串，最终返回一个字符串，注意连接一个number时需要在number与..之间加一个空格# -- 一元运算符，返回string或table的长度 运算符优先级 优先级 运算符 1 ^ 2 not、-（负号） 3 *、/ 4 +、-（减号） 5 .. 6 &lt;、&gt;、&lt;=、&gt;=、~=、== 7 and 8 or 除了^和..以外，其他所有的二元运算符都是从左向右结合 Lua字符串字符串表示方法123'a string' -- 单引号\"a string\" -- 双引号[[a string]] -- 双中括号 转义字符与C/C++相同 字符串操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111--[[作用：字符串全部转为大写字母参数列表： argument：原字符串返回值：转换为大写后的字符串]]string.upper(argument)--[[作用：字符串全部转为小写字母参数列表： argument：原字符串返回值：转换为小写后的字符串]]string.lower(argument)--[[作用：在字符串中替换，相当于其他语言的string.replace参数列表： mainString：要替换的字符串 findString：被替换的字符串 replaceString：要替换成的字符串 num：替换次数（忽略表示全部替换）返回值：替换后的字符串和实际替换次数]]string.gsub(mainString,findString,replaceString,num)--[[作用：查找子串参数列表： str：目标字符串 substr：子串 init：查找的起始索引 end：查找的末尾索引返回值：子串始末字符位置索引，不存在返回nil]]string.find(str,substr,[init,[end]])--[[作用：字符串反转参数列表： arg：原字符串返回值：反转后的字符串]]string.reverse(arg)--[[作用：返回一个类似C语言的printf的格式化字符串参数列表： ...：可变参数列表返回值：格式化字符串]]string.format(...)-- 示例string.format(\"the value is:%d\",4) -- 返回：the value is:4--[[作用：将整型数字转成字符并连接参数列表： arg：ASCCI码组成的参数列表返回值：一个由ASCCI码对应的字符连接成的字符串]]string.char(arg)--[[作用：转换字符为整数值参数列表： arg：字符串 int：指定字符串某索引位置的字符，默认为第一个字符返回值：字符对应的ASCCI码整数值]]string.byte(arg，[int])--[[作用：计算字符串长度参数列表： arg：字符串返回值：字符串长度]]string.len(arg)--[[作用：拷贝并连接n个字符串参数列表： string：字符串 n：拷贝次数返回值：字符串string的n个拷贝连接成的字符串]]string.rep(string,n)-- 连接字符串..--[[作用：查找下一个匹配的子串参数列表： str：字符串 pattern：正则匹配表达式返回值：一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串，如果没有找到子串，返回nil]]string.gmatch(str,pattern)--[[作用：寻找原字符串str中的第一个配对参数列表： str：字符串 pattern：正则匹配表达式 init：指定搜寻过程的起点，默认为1返回值：配对表达式中的所有捕获结果，即匹配到的字符串]]string.match(str,pattern,init) 字符串格式化除了%q，其余与C语言类似 12345-- %q接受一个字符串并将其转化为可安全被Lua编译器读入的格式，以下写法输出等价string.format(\"%q\",\"the\\nLua\")-- 输出以下字符串，与在Lua编辑器下编写换行的字符串等价\"the\\Lua\" 注意：%x与%X，%e与%E是不同的输出，前者输出都为小写字母，后者输出统一为大写字母 1234string.format(\"%x\",13) -- 输出dstring.format(\"%X\",13) -- 输出Dstring.format(\"%e\",1000) -- 输出1.000000e+03string.format(\"%E\",1000) -- 输出1.000000E+03 匹配模式https://www.runoob.com/lua/lua-strings.html","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Lua学习笔记（二）","slug":"Lua学习笔记（二）","date":"2019-07-15T11:12:00.000Z","updated":"2019-07-20T03:30:02.337Z","comments":true,"path":"2019/07/15/Lua学习笔记（二）/","link":"","permalink":"http://yoursite.com/2019/07/15/Lua学习笔记（二）/","excerpt":"","text":"Lua变量12345678910111213141516171819202122232425--[[Lua变量三种类型：全局变量（储存在名称为_G的table中）、局部变量、table中的域Lua中的变量全都是全局变量，即使在语句块或函数里，除非用local显式声明为局部变量局部变量作用域与C/C++概念相同变量默认值为nil]]-- test.lua文件脚本a=1 -- 全局变量local b=2 -- 文件内局部变量 function rua() c=5 -- 全局变量 local d=6 -- 局部变量endrua()print(c,d) --输出:5 nildo local a=6 -- 局部变量，这里局部变量覆盖了全局变量，引用外部全局变量时可以用_G.a来引用，类似于C/C++的::a b=6 -- 对局部变量重新赋值 print(a,b) -- 输出：6 6endprint(a,b) -- 输出：5 6 赋值语句123456789101112131415-- 赋值可以改变一个变量的值和表域a=\"hello\" .. \"world\"t.n=t.n+1-- 可以对多个变量同时赋值a,b=10,2*x -- a=10,b=2*x-- 赋值语句会先计算右边所有的值，然后再执行赋值操作-- 交换变量写法x,y=y,x--[[变量和值个数不一致:变量个数&gt;值的个数 按变量个数补足nil变量个数&lt;值的个数 多余的值被忽略]] a,b,c=0print(a,b,c) -- 输出：0 nil nil 索引1234-- table的索引使用方括号[]和点.的操作t[i]t.i -- 当索引为字符串类型时的一种简化写法gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用 Lua循环while循环123while(condition) do -- do somethingend 数值for循环1234-- var从exp1变化到exp2，每次变化以exp3为步长，可选，不指定默认为1for var=exp1,exp2,[exp3] do -- do somethingend 泛型for循环12345-- 相当于foreacha=&#123;\"a\",\"b\",\"c\"&#125;for i,v in ipairs(a) do print(i,v)end repeat…until循环1234-- 相当于C/C++的do...whilerepeat -- do somethinguntil(condition) break语句1234-- Lua仅支持break，不支持continue，同其他语言while(condition) do breakend Lua流程控制if语句123if(condition) then -- do somethingend if…else语句123456789101112131415-- 两条分支if(condition) then -- do somethingelse -- do somethingend-- 多条分支if(condition1) then -- do somethingelseif(condition2) then -- do somethingelse -- do somethingend","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Lua学习笔记（一）","slug":"Lua学习笔记（一）","date":"2019-07-15T01:27:00.000Z","updated":"2019-07-20T03:31:10.343Z","comments":true,"path":"2019/07/15/Lua学习笔记（一）/","link":"","permalink":"http://yoursite.com/2019/07/15/Lua学习笔记（一）/","excerpt":"","text":"注释12345678-- 单行注释--[[多行注释]]-- 等号数量只要两边一致即可--[=[多行注释]=] 标识符A-Z、a-z、下划线_开头后加上0个或多个字母、下划线、数字（0-9） 注意：最好不要使用下划线加大写字母，Lua保留字也是如此 不允许特殊字符@、$、%定义标识符 区分大小写 关键词1234-- Lua的保留关键字and break do else elseif end false for function if in local nil not or repeat return then true until while-- 一般约定，以下划线开头连接一串大写字母的名字（如_VERSION）被保留用于Lua内部全局变量_VERSION 全局变量123456789--[[默认情况下变量认为是全局的，不需要声明，赋值后即创建了这个全局变量，访问一个没有初始化的全局变量不会出错，会返回nil--]]print(b) -- 返回nilb=10print(b) -- 返回10-- 如果要删除一个全局变量，只需要将变量赋值为nilb=nilprint(b) -- 返回nil 数据类型12345678910111213-- Lua是动态类型语言，不需要定义，只需要赋值。值可以储存在变量中，作为参数传递或结果返回-- 8个基本类型nil、boolean、number、string、userdata、function、thread、table--[[nil 只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）boolean 包含两个值：false和truenumber 双精度类型的实浮点数string 字符串由一对双引号或单引号来表示function 由C或Lua编写的函数userdata 表示任意存储在变量中的C数据结构thread 表示执行的独立线程，用于执行协程table Lua中的表是一个“关联数组”，数组的索引可以是数字、字符串或表类型。在Lua里，table的创建时通过“构造表达式”来完成，最简单构造表达式是&#123;&#125;，用来创建一个空表]]type() -- 该函数可以测试给定变量或者值得类型 nil（空）123456789101112-- nil类型表示没有任何有效值，它只有一个值nilprint(type(a)) -- 输出nil-- 对于全局变量和table，nil有删除的作用tab1=&#123;key1=\"val1\",key2=\"val2\",\"val3\"&#125;for k,v in pairs(tab1) do print(k .. \" - \" .. v) -- ..运算符用于连接字符串endtab1.key1=nilfor k,v in pairs(tab1) do print(k .. \" - \" .. v)end boolean（布尔）1234567-- 只有两个可选值：false、true，Lua把false和nil看作是“假”，其他的都为真if false or nil then print(\"至少有一个是true\")else print(\"false和nil都为false！\")end-- 执行结果为false和nil都为false！ number（数字）123-- Lua默认只有一种number类型 double（双精度）类型print(type(2)) -- 输出numberprint(type(2e+1)) -- 输出number string（字符串）123456789101112131415161718string1=\"this is string1\"string2=\"this is string2\"-- 也可以用两个方括号“[[]]”来表示“一块”字符串，输出时会将换行和制表等格式也输出string3=[[emmmmmmmmmmaaaaaaaaaaaruaruaruaruarua!]]-- 对一个数字字符串进行算术操作，Lua会尝试将这个数字字符串转成一个数字print(\"2\"+6) -- 输出8.0print(\"-2e2\"*\"6\") -- 输出-1200.0-- 字符串连接使用..操作符，注意操作对象如果为数字，则操作对象与操作符之间需要加空格print(\"2\"..\"b\") -- 输出2bprint(233 .. 666) -- 输出233666-- 使用#来计算字符串长度，放在字符串前面len=\"www.rua.com\"print(#len) -- 输出11print(#\"helloworld\") -- 输出10 table（表）12345678910111213141516171819202122-- 创建一个空表local tbl1=&#123;&#125;-- 直接初始表local tbl2=&#123;\"a\",\"b\",\"c\",\"d\"&#125;-- 创建键值对a[\"key\"]=\"value\"a[1]=22key=10 -- 这里只是赋值，赋值后用于后面的创建键值对a[key]=22a[a[key]]=a[key]+11-- 在Lua中，默认初始索引一般以1开始local tb1=&#123;\"a\",\"b\",\"c\"&#125;for key,val in pairs(tb1) do print(\"Key\",key)end--[[输出：Key 1Key 2Key 3]]-- table的长度是动态增长的 function（函数）1234567891011121314151617181920212223242526272829-- 在Lua中，函数是被看作“第一类值（First-Class Value）”，函数可以存在变量里function fun1(n) -- 一个递归求阶乘的函数 if n == 0 then return 1 else return n*fun1(n-1) endendprint(fun1(5)) -- 输出120fun2=fun1print(fun2(5)) -- 输出120-- 也可以使用匿名函数的形式function testFun(tab,fun) for k,v in pairs(tab) do print(fun(k,v)) endendtab=&#123;kay1=\"val1\",key2=\"val2\"&#125;testFun(tab, function(key,val) return key .. \"=\" .. val end)--[[执行结果:key1=val1key2=val2]] thread（线程）Lua中主要的线程是协程（coroutine） 线程可以同时多个运行，协程任意时刻智能运行一个 userdata（自定义类型）用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型，可以将任意C/C++的任意数据类型的数据（通常是struct和指针）存储到Lua变量中调用","categories":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/categories/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"Unity3D学习笔记之UGUI：Canvas","slug":"Unity3D学习笔记之UGUI：Canvas","date":"2018-11-27T09:35:30.000Z","updated":"2018-12-08T15:29:25.748Z","comments":true,"path":"2018/11/27/Unity3D学习笔记之UGUI：Canvas/","link":"","permalink":"http://yoursite.com/2018/11/27/Unity3D学习笔记之UGUI：Canvas/","excerpt":"","text":"Canvas组件： Rander Mode（渲染模式）： （默认）Screen Space - Overlay（屏幕空间叠加模式）：自动填充场景，使Canvas自动适应Game窗口的大小，并且在此模式下Rect Transform组件不可编辑，其中的所有值将由Canvas自动设置 Pixel Perfect：开启时，UI元素将在渲染时调整到最近的像素，使外观更加锐利 Sort Order：表示该Canvas渲染的顺序，数字越大越迟进渲染管线，位置处于越上层 Target Display：表示渲染到的目标显示窗 Screen Space - Camera（屏幕空间相机模式）：和1类似，但是Canvas是直接填充到相机的截锥体中，并且可以设置独立的相机，允许UI元素有深度感 Pixel Perfect：同上 Render Camera：渲染此Canvas的相机 Plane Distance：Canvas离相机的距离 Sorting Layer：渲染顺序层级 Order in Layer：在当前渲染顺序层级的子渲染顺序 World Space（世界空间模式）：此模式下的UI元素可以是场景中的静态元素或者是可移动元素，并且Rect Transform组件允许设置，不再随屏幕的变化而变化 Event Camera：检测点击UI等事件的相机 Sorting Layer：同上 Order in Layer：同上 Canvas Scaler组件： UI Scale Mode（缩放模式）： Constant Pixel Size：固定像素尺寸，无论分辨率是多少，占用的像素都是一样的 Scale Factor：缩放比例，默认为1 Scale With Screen Size：根据屏幕大小进行缩放 Reference Resolution：开发时设置的分辨率，所有的缩放基于这个分辨率 Screen Match Mode：屏幕适配模式 Match Width Or Height（默认）：匹配宽度或高度 Match：宽度和高度的缩放权重，横屏游戏用Height匹配，竖屏游戏用Width匹配 Expend：如果屏幕实际大小大于参考标准时，选用此模式，它会适当放大Canvas Shrink：如果屏幕实际大小小于参考标准时，选用此模式，它会适当缩小Canvas Constant Physical Size：物理大小不变模式 Physical Unit：物理单位 Centimeters（厘米）：0.01米 Millimeters（毫米）：0.1厘米 Inches（英寸）：英制单位 Points（积分）：1/72英寸 Picas（派卡）：1/6英寸 Fallback Screen DPI：屏幕DPI Default Sprite DPI：默认精灵DPI Reference Pixels Per Unit（参考像素每单位）：每个单位的参考像素，和1x1x1的Cube来比较，棱长1表示一个单位，一个单位由n个像素组成，n即为此项的值，默认为100","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"Unity3D学习笔记之碰撞器和触发器","slug":"Unity3D学习笔记之碰撞器和触发器","date":"2018-11-21T14:15:22.000Z","updated":"2018-11-21T14:16:31.498Z","comments":true,"path":"2018/11/21/Unity3D学习笔记之碰撞器和触发器/","link":"","permalink":"http://yoursite.com/2018/11/21/Unity3D学习笔记之碰撞器和触发器/","excerpt":"","text":"碰撞器种类： Box Collider（盒碰撞器）——立方体 Sphere Collider（球碰撞器）——球体 Capsule Collider（胶囊碰撞器）——胶囊体 Mesh Collider（网格碰撞器）——从物体的网格创建一个碰撞器，不能与其他网格碰撞器相碰撞 Wheel Collider（轮碰撞器）——特殊的碰撞器，用于创建车或其他的交通工具的车轮 碰撞器属性： Material：材质 Is Trigger：开启触发器 Radius：半径 Center：中心 Size：碰撞器的大小 Convex（网格碰撞器特有）：如激活，该网格碰撞器将会和其他网格碰撞器碰撞，突起的网格碰撞器限制在255个三角形面内。 碰撞器类型： Static Collider（静态碰撞器）：只有碰撞器，没有刚体。基本保持静止或者轻微的移动，一般应用于环境模型，和刚体碰撞时不会移动 Rigidbody Collider（刚体碰撞器）：同时附加了刚体和碰撞器。移动完全受脚本和物理引擎的影响。 Kinematic Rigidbody Collider（运动学刚体碰撞器）：同时附加刚体和碰撞器，并且激活刚体组件的IsKinematic。移动必须通过修改其Transform组件，不受力的影响。能影响其他的刚体，和其他碰撞器碰撞时不会受影响，但是会触发碰撞函数。 Character Controllers（角色控制器）：允许高速运动时立刻转身，可以执行碰撞检测保证角色可以沿墙滑动或者上下台阶。受重力影响，不受碰撞产生的力影响，可以由代码施加的力推动。不具有物理特性。如果想让角色控制器推开其他刚体或者对象，可以在对象附加的脚本中添加OnControllerColliderHit()函数，使得碰撞生效。 触发器：在碰撞器的属性面版上勾选上IsTrigger便成为了触发器 两者区别：碰撞器根据物理引擎引发碰撞，产生碰撞的效果；触发器被物理引擎所忽略，没有碰撞效果 碰撞信息检测函数： OnCollisionEnter(Collision collision)当开始产生碰撞时调用此函数 OnCollisionExit(Collision collision)当结束碰撞时调用此函数 OnCollisionStay(Collision collision)当持续接触时调用此函数 触发信息检测函数：基本和碰撞信息检测函数类似 OnTriggerEnter(Collision collision) OnTriggerExit(Collision collision) OnTriggerStay(Collision collision) 碰撞信息和触发信息：​ 碰撞后有碰撞检测并有碰撞信息发出 Static Collider 静态碰撞器 Rigidbody Collider 刚体碰撞器 Kinematic Rigidbody Collider 运动学刚体碰撞器 Static Trigger Collider 静态触发碰撞器 Rigidbody Trigger Collider 刚体触发碰撞器 Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器 Static Collider 静态碰撞器 Y Rigidbody Collider 刚体碰撞器 Y Y Y Kinematic Rigidbody Collider 运动学刚体碰撞器 Y Static Trigger Collider 静态触发碰撞器 Rigidbody Trigger Collider 刚体触发碰撞器 Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器 ​ 碰撞后有触发信息 Static Collider 静态碰撞器 Rigidbody Collider 刚体碰撞器 Kinematic Rigidbody Collider 运动学刚体碰撞器 Static Trigger Collider 静态触发碰撞器 Rigidbody Trigger Collider 刚体触发碰撞器 Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器 Static Collider 静态碰撞器 Y Y Rigidbody Collider 刚体碰撞器 Y Y Y Kinematic Rigidbody Collider 运动学刚体碰撞器 Y Y Y Static Trigger Collider 静态触发碰撞器 Y Y Y Y Rigidbody Trigger Collider 刚体触发碰撞器 Y Y Y Y Y Y Kinematic Rigidbody Trigger Collider 运动学刚体触发碰撞器 Y Y Y Y Y Y","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"Unity3D学习笔记之Rigidbody(刚体组件)","slug":"Unity3D学习笔记之Rigidbody-刚体组件","date":"2018-10-28T06:38:54.000Z","updated":"2018-10-28T07:01:04.518Z","comments":true,"path":"2018/10/28/Unity3D学习笔记之Rigidbody-刚体组件/","link":"","permalink":"http://yoursite.com/2018/10/28/Unity3D学习笔记之Rigidbody-刚体组件/","excerpt":"","text":"Rigidbody面板各属性： Mass（质量）：单位kg Drag（阻力） Angular Drag（角阻力） Use Gravity（开启重力） Is Kinematic（开启动力学模式）：开启之后将不在受物理引擎的影响而只能通过Transform属性来操作，这个选项适用于模拟平台的移动或带有铰链关节连接刚体的动画。 Interpolate（插值）： ​ None：没有插值。 ​ Interpolate：内插值，基于前一帧的Transform来平滑的此次的Transform。 ​ Extrapolate：外插值，基于后一帧的Transform来平滑的此次的Transform。 Collision Detection（碰撞检测模式）： ​ Discrete：默认选项，检测场景中其他所有碰撞体进行碰撞检测。 ​ Continuous：连续碰撞检测。此模式适用于那些需要与采用了连续动态碰撞检测的对象相碰撞的对象。 ​ Continuous Dynamic：连续动态检测模式。 Constraints（束缚）： Freeze Position（位置冻结） Freeze Rotation（角度冻结） 脚本中控制刚体的常用方法： AddForce：添加一个力到刚体，使刚体开始移动 AddForceAtPosition：施加在某一个点上的力，这将可能在物体上施加扭矩力 Addtorque：为刚体增加一个扭矩 IsSleeping：判断刚体是否被休眠 MovePosition：移动刚体到某个位置 MoveRotation：使刚体旋转到某个位置 Sleep：使刚体至少休眠一帧 WakeUp：使刚体终止休眠 GetPointVelocity：获取刚体的绝对速度 GetRelativePointVelocity：获取刚体相对于某点的速度 ResetInertiaTensor：重置惯性张量和旋转 刚体物理学知识补充： 刚体：指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。 惯性张量：描述刚体绕点旋转的惯性大小 转动惯量：描述刚体绕轴旋转的惯性大小 惯性张量与转动惯量的关系： 对于三维空间中任意一参考点 K与以此参考点为原点的直角坐标系的惯性张量I可以表示为下面的3X3的矩阵 这里，矩阵的对角元素 Ixx、Iyy、Izz分别为对于 x-轴、y-轴、z-轴的转动惯量 注意事项： 操作一个物体可以操作其刚体或者Transform属性，两者选其一即可； 使用物理系统时可以通过在游戏对象的刚体上添加AddForce()或者AddTorque()函数达到通过脚本来添加作用力或扭矩力，来对刚体进行控制； 使用刚体组件也要同时使用碰撞器组件； 父子对象不应该同时具有刚体； 不应该缩放刚体的父级。 运动学刚体不受力、碰撞或关节控制，完全由动画或代码（控制Transform属性）驱动，但运动学刚体可以通过碰撞或关节影响其他刚体的运动。非运动学刚体则受力、碰撞或关节控制。 详细API请参考：https://docs.unity3d.com/ScriptReference/Rigidbody.html","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！","slug":"C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！","date":"2018-10-24T17:09:44.000Z","updated":"2018-11-21T14:27:13.952Z","comments":true,"path":"2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/","link":"","permalink":"http://yoursite.com/2018/10/25/C++的ifstream中使用eof最后一个字符输出两次，其实不是eof的锅！/","excerpt":"","text":"写C++文件输入输出流时遇到的小问题 当我执行以下代码时，最后的值会打印两次： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;fstream&gt;using namespace std;int main(void)&#123; int a = 0,b = 1,c = 2,d = 3; char ch; ofstream FileOpen(\"Test.txt\"); FileOpen&lt;&lt;\"HelloWorld!\\n\"; FileOpen&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d; FileOpen.close(); ifstream Filein(\"Test.txt\"); while(!Filein.eof()) &#123; Filein.get(ch); cout&lt;&lt;ch; &#125; Filein.close(); cout&lt;&lt;endl; system(\"pause\"); return 0;&#125; 问题在于get()方法：get()方法返回当前文件“内置指针”指向的下一个字符，然后再将“内置指针”向后移动。 也就是说“内置指针”是在执行完get()后才指向下一个字符。 下面来分析一下波：当“内置指针”指向c时，get()返回d的值给ch，然后“内置指针”向后移动指向d，打印d的值，此时eof()返回false，而循环继续进行; 再次get()，当前“内置指针”指向d，返回的是d后面的值，然而d后面是EOF，读取失败，无法赋值给ch，ch依然为d的值，再次打印了一次d的值，get()完后，“内置指针”指向了EOF，eof()返回true，则退出而循环。 结束。 原理已经懂了，进行以下的改造即可输出正确：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;fstream&gt;using namespace std;int main(void)&#123; int a = 0,b = 1,c = 2,d = 3; char ch; ofstream FileOpen(“Test.txt”); FileOpen &lt;&lt; \"Helloworld!\\n\"; FileOpen &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d; FileOpen.close(); ifstream Filein(\"Test.txt\"); if(Filein.get(ch),!Filein.eof()) &#123; cout &lt;&lt; ch; &#125; cout &lt;&lt; endl; system(\"pause\"); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"文件输入输出流","slug":"文件输入输出流","permalink":"http://yoursite.com/tags/文件输入输出流/"}]},{"title":"Unity终止协程的问题","slug":"Unity终止协程的问题","date":"2018-10-23T15:17:30.000Z","updated":"2019-01-17T07:17:59.157Z","comments":true,"path":"2018/10/23/Unity终止协程的问题/","link":"","permalink":"http://yoursite.com/2018/10/23/Unity终止协程的问题/","excerpt":"","text":"最近在项目开发的时候发现，调用StopCoroutine()来终止一个正在运行的协程的时候，无法终止协程。然后通过查资料发现了一下两种办法： 利用字符串来启动和终止协程：比如，我有一个协程IEnumerator MoveAnimation()，启动时要用StartCoroutine(&quot;MoveAnimation&quot;)，终止的时候用StopCoroutine(&quot;MoveAnimation&quot;)，才能正确终止协程。 要想传参，可以使用 StartCoroutine(&quot;MoveAnimation&quot;, object)来传参。 不用字符串来启动和终止协程的方法：定义一个Coroutine类型的变量coroutine，在StartCoroutine(MoveAnimation())后接收返回的值： coroutine=StartCoroutine(&quot;MoveAnimation&quot;); 然后终止协程的时候利用StopCoroutine(coroutine)来终止。","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"Unity界面UGUI遮挡的问题","slug":"Unity界面UGUI遮挡的问题","date":"2018-10-22T12:22:45.000Z","updated":"2018-11-04T14:53:17.801Z","comments":true,"path":"2018/10/22/Unity界面UGUI遮挡的问题/","link":"","permalink":"http://yoursite.com/2018/10/22/Unity界面UGUI遮挡的问题/","excerpt":"","text":"解决方法：在使用Unity的UGUI时候，重叠的UI控件可能会导致某一个控件点击失败，如下图： 在前面的图片挡住了后面的Button，导致后面的Button无法触发点击事件，此时只要把图片的Image组件的Raycast Target的勾选取消即可解决遮挡的问题： 原理：鼠标点击屏幕实际上是以点击的点为原点，发射一条垂直屏幕向里的射线，然后通过射线与第一个物体的相交来判断是否点击到该物体。取消了Raycast Target选项表明不作为射线相交的对象，则不会挡住后面的Button","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/tags/Unity/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yoursite.com/tags/游戏开发/"}]},{"title":"steam商店页面的探索队列无法打开","slug":"steam商店页面的探索队列无法打开","date":"2018-10-21T15:43:04.000Z","updated":"2018-10-21T16:04:55.042Z","comments":true,"path":"2018/10/21/steam商店页面的探索队列无法打开/","link":"","permalink":"http://yoursite.com/2018/10/21/steam商店页面的探索队列无法打开/","excerpt":"","text":"steam的探索队列可能会显示“你所在的地区不提供此物品”，此时如何解决呢？ 用浏览器打开steam商店页面： 然后按F12打开浏览器控制台（Console）： 然后在右边输入以下代码：$J.post(&quot;/app/7&quot;, { sessionid: g_sessionID, appid_to_clear_from_queue: APPID }); 注意：其中的APPID由你当前队列的网址的以下数字串决定，把你对应的数字串替换上面代码的APPID即可","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"steam","slug":"steam","permalink":"http://yoursite.com/tags/steam/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]}]}